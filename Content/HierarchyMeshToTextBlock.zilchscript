[RunInEditor]
class HierarchyMeshToTextBlock : ToTextBlockBase
{
  [Property] var ApplyTransform : Boolean = true;
  
  [Property]
  function Save()
  {
    var fileName = this.GenerateVertexFileName(this.Owner.Name);
    this.SaveVertices(fileName, this.GetVertices());
  }
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.Owner, Events.QueryQuickHullVertices, this.OnQueryQuickHullVertices);
    Zero.Connect(this.Space, Events.SaveVertices, this.OnSaveVertices);
  }

  function OnSaveVertices(event : ZilchEvent)
  {
    this.Save();
  }
  
  function OnQueryQuickHullVertices(event : QuickHullVertexQueryEvent)
  {
    event.Vertices = this.GetVertices();
  }
  
  function GetVertices() : Array[Real3]
  {
    var output = Array[Real3]();
    
    var parentInverse = Real4x4();
    parentInverse.SetIdentity();
    if(!this.ApplyTransform)
      parentInverse = Math.Invert(this.Owner.Transform.WorldMatrix);
    
    this.GetVertices(this.Owner, output, parentInverse);
    return output;
  }
  
  function GetVertices(cog : Cog, output : Array[Real3], parentInverse : Real4x4)
  {
    if(cog.Model != null)
    {
      var mesh = cog.Model.Mesh;
      var worldMatrix = Math.Multiply(parentInverse, cog.Transform.WorldMatrix);
      this.GetVertices(mesh, worldMatrix, output);
    }
    
    foreach(var child in cog.Children)
    {
      this.GetVertices(child, output, parentInverse);
    }
  }
  
  function GetVertices(mesh : Mesh, transform : Real4x4, output : Array[Real3])
  {
    for(var i = 0; i < mesh.Vertices.VertexCount; ++i)
    {
      var pos = mesh.Vertices.GetVertexData(i, VertexSemantic.Position).XYZ;
      pos = Math.MultiplyPoint(transform, pos);
      output.Add(pos.XYZ);
    }
  }
}
