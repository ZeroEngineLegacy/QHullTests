enum RandomType{Sphere, Box, SphericalShell, BoxShell, GaussianSpherical}

[RunInEditor]
class RandomPointGeneration : ToTextBlockBase
{
  var Points : Array[Real3] = Array[Real3]();
  var SearchPoint : Real3 = Real3();
  
  [Dependency] var RandomContext : RandomContext;
  
  [Property] var TestName : String = "RandomTest";
  [Property] var RandomPointCount : Integer = 20;
  [Property] var RandomRadius : Real = 10.0;
  [Property] var RandomType : RandomType = RandomType.Sphere;
  [Property] var PointArchetype : Archetype = Archetype.Point;
  
  [Property] function CreatePoints()
  {
    var vertices = Array[Real3]();
    
    var random = this.RandomContext;
    for(var i = 0; i < this.RandomPointCount; ++i)
    {
      var pos = Real3();
      if(this.RandomType == RandomType.Sphere)
        pos = random.Vector3(0, this.RandomRadius);
      else if(this.RandomType == RandomType.Box)
      {
        pos.X = random.RealVariance(0, this.RandomRadius);
        pos.Y = random.RealVariance(0, this.RandomRadius);
        pos.Z = random.RealVariance(0, this.RandomRadius);
      }
      else if(this.RandomType == RandomType.SphericalShell)
      {
        pos = random.UnitVector3() * this.RandomRadius;
      }
      else if(this.RandomType == RandomType.BoxShell)
      {
        pos.X = random.RealVariance(0, this.RandomRadius);
        pos.Y = random.RealVariance(0, this.RandomRadius);
        pos.Z = random.RealVariance(0, this.RandomRadius);
        
        var absPos = Math.Abs(pos);
        if(absPos.X > absPos.Y && absPos.X > absPos.Z)
          pos.X = Math.Sign(pos.X) * this.RandomRadius;
        else if(absPos.Y > absPos.X && absPos.Y > absPos.Z)
          pos.Y = Math.Sign(pos.Y) * this.RandomRadius;
        else
          pos.Z = Math.Sign(pos.Z) * this.RandomRadius;
      }
      else if(this.RandomType == RandomType.GaussianSpherical)
      {
        var radius = random.RealVariance(0, this.RandomRadius);
        var phi = random.Range(0, Math.Pi);
        var theta = random.Range(0, 2 * Math.Pi);
        var sinPhi = Math.Sin(phi);
        var cosPhi = Math.Cos(phi);
        var sinTheta = Math.Sin(theta);
        var cosTheta = Math.Cos(theta);
        
        pos.X = sinPhi * cosTheta;
        pos.Y = cosPhi;
        pos.Z = sinPhi * sinTheta;
        pos *= radius;
      }
      
      pos += this.Owner.Transform.WorldTranslation;
      vertices.Add(pos);
    }
    
    
    this.Load(vertices);
  }
  
  [Property]
  function Save()
  {
    var output = Array[Real3]();
    
    foreach(var child in this.Owner.Children)
      output.Add(child.Transform.WorldTranslation);
      
    var fileName = this.GenerateVertexFileName(this.TestName);
    this.SaveVertices(fileName, output);
  }
  
  [Property]
  function Load()
  {
    var fileName = this.GenerateVertexFileName(this.TestName);
    var input = this.LoadVertices(fileName);
    
    this.Load(input);
  }
  
  function Load(vertices : Array[Real3])
  {
    var queue = Zero.Editor.OperationQueue;
    queue.BeginBatch();
    
    var children = this.Owner.ChildrenArray;
    foreach(var child in children)
    {
      queue.DestroyObject(child);
    }
    
    foreach(var vertex in vertices)
    {
      var cog = this.Space.CreateAtPosition(this.PointArchetype, vertex);
      cog.AttachTo(this.Owner);
      queue.ObjectCreated(cog);
    }
    
    queue.EndBatch();
  }
  
  [Property] function Clear()
  {
    var queue = Zero.Editor.OperationQueue;
    queue.BeginBatch();
    
    var children = this.Owner.ChildrenArray;
    foreach(var child in children)
    {
      queue.DestroyObject(child);
    }
    
    queue.EndBatch();
  }
}